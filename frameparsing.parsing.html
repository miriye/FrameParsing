<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module frameparsing.parsing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong><a href="frameparsing.html"><font color="#ffffff">frameparsing</font></a>.parsing</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:c%3A%5Cusers%5Cisabe%5Conedrive%5Cdocuments%5Cgithub%5Cframetools%5Cframeparsing%5Cparsing.py">c:\users\isabe\onedrive\documents\github\frametools\frameparsing\parsing.py</a></font></td></tr></table>
    <p></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="re.html">re</a><br>
</td><td width="25%" valign=top></td><td width="25%" valign=top></td><td width="25%" valign=top></td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#str">builtins.str</a>(<a href="builtins.html#object">builtins.object</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="frameparsing.parsing.html#Seqname">Seqname</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Seqname">class <strong>Seqname</strong></a>(<a href="builtins.html#str">builtins.str</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Seqname">Seqname</a>(string,&nbsp;*args,&nbsp;**kwargs)<br>
&nbsp;<br>
Formattable&nbsp;string&nbsp;representing&nbsp;the&nbsp;names&nbsp;of&nbsp;a&nbsp;sequence&nbsp;of&nbsp;files.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="frameparsing.parsing.html#Seqname">Seqname</a></dd>
<dd><a href="builtins.html#str">builtins.str</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Seqname-__init__"><strong>__init__</strong></a>(self, string: str)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Seqname-matches"><strong>matches</strong></a>(self, string: str, strict: bool = True) -&gt; bool</dt><dd><tt>Determine&nbsp;whether&nbsp;the&nbsp;given&nbsp;string&nbsp;matches&nbsp;this&nbsp;format.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;string&nbsp;to&nbsp;check&nbsp;for&nbsp;a&nbsp;match.<br>
&nbsp;&nbsp;&nbsp;&nbsp;strict:&nbsp;If&nbsp;True,&nbsp;match&nbsp;seqname&nbsp;exactly&nbsp;from&nbsp;start&nbsp;to&nbsp;end&nbsp;of&nbsp;string.&nbsp;If&nbsp;False,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;anywhere&nbsp;in&nbsp;the&nbsp;string.&nbsp;Defaults&nbsp;to&nbsp;True.&nbsp;<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;matches&nbsp;this&nbsp;seqname,&nbsp;False&nbsp;if&nbsp;not.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="Seqname-__new__"><strong>__new__</strong></a>(cls, string, *args, **kwargs)</dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;object.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Readonly properties defined here:<br>
<dl><dt><strong>format_code</strong></dt>
<dd><tt>String&nbsp;in&nbsp;"format_code"&nbsp;format.&nbsp;E.g:&nbsp;"frame{:04d}.png".</tt></dd>
</dl>
<dl><dt><strong>modulo</strong></dt>
<dd><tt>String&nbsp;in&nbsp;"modulo"&nbsp;format.&nbsp;E.g:&nbsp;"frame%04d.png".</tt></dd>
</dl>
<dl><dt><strong>numbersign</strong></dt>
<dd><tt>String&nbsp;in&nbsp;"numbersign"&nbsp;format.&nbsp;e.g:&nbsp;"frame####.png".</tt></dd>
</dl>
<dl><dt><strong>regex</strong></dt>
<dd><tt>Regex&nbsp;that&nbsp;will&nbsp;match&nbsp;files&nbsp;matching&nbsp;this&nbsp;format.</tt></dd>
</dl>
<dl><dt><strong>width</strong></dt>
<dd><tt>The&nbsp;fill&nbsp;width&nbsp;of&nbsp;the&nbsp;framecode&nbsp;in&nbsp;this&nbsp;seqname.</tt></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Methods inherited from <a href="builtins.html#str">builtins.str</a>:<br>
<dl><dt><a name="Seqname-__add__"><strong>__add__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self+value.</tt></dd></dl>

<dl><dt><a name="Seqname-__contains__"><strong>__contains__</strong></a>(self, key, /)</dt><dd><tt>Return&nbsp;key&nbsp;in&nbsp;self.</tt></dd></dl>

<dl><dt><a name="Seqname-__eq__"><strong>__eq__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self==value.</tt></dd></dl>

<dl><dt><a name="Seqname-__format__"><strong>__format__</strong></a>(self, format_spec, /)</dt><dd><tt>Return&nbsp;a&nbsp;formatted&nbsp;version&nbsp;of&nbsp;the&nbsp;string&nbsp;as&nbsp;described&nbsp;by&nbsp;format_spec.</tt></dd></dl>

<dl><dt><a name="Seqname-__ge__"><strong>__ge__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self&gt;=value.</tt></dd></dl>

<dl><dt><a name="Seqname-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="Seqname-__getitem__"><strong>__getitem__</strong></a>(self, key, /)</dt><dd><tt>Return&nbsp;self[key].</tt></dd></dl>

<dl><dt><a name="Seqname-__getnewargs__"><strong>__getnewargs__</strong></a>(...)</dt></dl>

<dl><dt><a name="Seqname-__gt__"><strong>__gt__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self&gt;value.</tt></dd></dl>

<dl><dt><a name="Seqname-__hash__"><strong>__hash__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;hash(self).</tt></dd></dl>

<dl><dt><a name="Seqname-__iter__"><strong>__iter__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;iter(self).</tt></dd></dl>

<dl><dt><a name="Seqname-__le__"><strong>__le__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self&lt;=value.</tt></dd></dl>

<dl><dt><a name="Seqname-__len__"><strong>__len__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;len(self).</tt></dd></dl>

<dl><dt><a name="Seqname-__lt__"><strong>__lt__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self&lt;value.</tt></dd></dl>

<dl><dt><a name="Seqname-__mod__"><strong>__mod__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self%value.</tt></dd></dl>

<dl><dt><a name="Seqname-__mul__"><strong>__mul__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self*value.</tt></dd></dl>

<dl><dt><a name="Seqname-__ne__"><strong>__ne__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;self!=value.</tt></dd></dl>

<dl><dt><a name="Seqname-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Seqname-__rmod__"><strong>__rmod__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;value%self.</tt></dd></dl>

<dl><dt><a name="Seqname-__rmul__"><strong>__rmul__</strong></a>(self, value, /)</dt><dd><tt>Return&nbsp;value*self.</tt></dd></dl>

<dl><dt><a name="Seqname-__sizeof__"><strong>__sizeof__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;string&nbsp;in&nbsp;memory,&nbsp;in&nbsp;bytes.</tt></dd></dl>

<dl><dt><a name="Seqname-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;<a href="builtins.html#str">str</a>(self).</tt></dd></dl>

<dl><dt><a name="Seqname-capitalize"><strong>capitalize</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;capitalized&nbsp;version&nbsp;of&nbsp;the&nbsp;string.<br>
&nbsp;<br>
More&nbsp;specifically,&nbsp;make&nbsp;the&nbsp;first&nbsp;character&nbsp;have&nbsp;upper&nbsp;case&nbsp;and&nbsp;the&nbsp;rest&nbsp;lower<br>
case.</tt></dd></dl>

<dl><dt><a name="Seqname-casefold"><strong>casefold</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;version&nbsp;of&nbsp;the&nbsp;string&nbsp;suitable&nbsp;for&nbsp;caseless&nbsp;comparisons.</tt></dd></dl>

<dl><dt><a name="Seqname-center"><strong>center</strong></a>(self, width, fillchar=' ', /)</dt><dd><tt>Return&nbsp;a&nbsp;centered&nbsp;string&nbsp;of&nbsp;length&nbsp;width.<br>
&nbsp;<br>
Padding&nbsp;is&nbsp;done&nbsp;using&nbsp;the&nbsp;specified&nbsp;fill&nbsp;character&nbsp;(default&nbsp;is&nbsp;a&nbsp;space).</tt></dd></dl>

<dl><dt><a name="Seqname-count"><strong>count</strong></a>(...)</dt><dd><tt>S.<a href="#Seqname-count">count</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;number&nbsp;of&nbsp;non-overlapping&nbsp;occurrences&nbsp;of&nbsp;substring&nbsp;sub&nbsp;in<br>
string&nbsp;S[start:end].&nbsp;&nbsp;Optional&nbsp;arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are<br>
interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.</tt></dd></dl>

<dl><dt><a name="Seqname-encode"><strong>encode</strong></a>(self, /, encoding='utf-8', errors='strict')</dt><dd><tt>Encode&nbsp;the&nbsp;string&nbsp;using&nbsp;the&nbsp;codec&nbsp;registered&nbsp;for&nbsp;encoding.<br>
&nbsp;<br>
encoding<br>
&nbsp;&nbsp;The&nbsp;encoding&nbsp;in&nbsp;which&nbsp;to&nbsp;encode&nbsp;the&nbsp;string.<br>
errors<br>
&nbsp;&nbsp;The&nbsp;error&nbsp;handling&nbsp;scheme&nbsp;to&nbsp;use&nbsp;for&nbsp;encoding&nbsp;errors.<br>
&nbsp;&nbsp;The&nbsp;default&nbsp;is&nbsp;'strict'&nbsp;meaning&nbsp;that&nbsp;encoding&nbsp;errors&nbsp;raise&nbsp;a<br>
&nbsp;&nbsp;UnicodeEncodeError.&nbsp;&nbsp;Other&nbsp;possible&nbsp;values&nbsp;are&nbsp;'ignore',&nbsp;'replace'&nbsp;and<br>
&nbsp;&nbsp;'xmlcharrefreplace'&nbsp;as&nbsp;well&nbsp;as&nbsp;any&nbsp;other&nbsp;name&nbsp;registered&nbsp;with<br>
&nbsp;&nbsp;codecs.register_error&nbsp;that&nbsp;can&nbsp;handle&nbsp;UnicodeEncodeErrors.</tt></dd></dl>

<dl><dt><a name="Seqname-endswith"><strong>endswith</strong></a>(...)</dt><dd><tt>S.<a href="#Seqname-endswith">endswith</a>(suffix[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;bool<br>
&nbsp;<br>
Return&nbsp;True&nbsp;if&nbsp;S&nbsp;ends&nbsp;with&nbsp;the&nbsp;specified&nbsp;suffix,&nbsp;False&nbsp;otherwise.<br>
With&nbsp;optional&nbsp;start,&nbsp;test&nbsp;S&nbsp;beginning&nbsp;at&nbsp;that&nbsp;position.<br>
With&nbsp;optional&nbsp;end,&nbsp;stop&nbsp;comparing&nbsp;S&nbsp;at&nbsp;that&nbsp;position.<br>
suffix&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;tuple&nbsp;of&nbsp;strings&nbsp;to&nbsp;try.</tt></dd></dl>

<dl><dt><a name="Seqname-expandtabs"><strong>expandtabs</strong></a>(self, /, tabsize=8)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;where&nbsp;all&nbsp;tab&nbsp;characters&nbsp;are&nbsp;expanded&nbsp;using&nbsp;spaces.<br>
&nbsp;<br>
If&nbsp;tabsize&nbsp;is&nbsp;not&nbsp;given,&nbsp;a&nbsp;tab&nbsp;size&nbsp;of&nbsp;8&nbsp;characters&nbsp;is&nbsp;assumed.</tt></dd></dl>

<dl><dt><a name="Seqname-find"><strong>find</strong></a>(...)</dt><dd><tt>S.<a href="#Seqname-find">find</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;lowest&nbsp;index&nbsp;in&nbsp;S&nbsp;where&nbsp;substring&nbsp;sub&nbsp;is&nbsp;found,<br>
such&nbsp;that&nbsp;sub&nbsp;is&nbsp;contained&nbsp;within&nbsp;S[start:end].&nbsp;&nbsp;Optional<br>
arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are&nbsp;interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.<br>
&nbsp;<br>
Return&nbsp;-1&nbsp;on&nbsp;failure.</tt></dd></dl>

<dl><dt><a name="Seqname-format"><strong>format</strong></a>(...)</dt><dd><tt>S.<a href="#Seqname-format">format</a>(*args,&nbsp;**kwargs)&nbsp;-&gt;&nbsp;<a href="builtins.html#str">str</a><br>
&nbsp;<br>
Return&nbsp;a&nbsp;formatted&nbsp;version&nbsp;of&nbsp;S,&nbsp;using&nbsp;substitutions&nbsp;from&nbsp;args&nbsp;and&nbsp;kwargs.<br>
The&nbsp;substitutions&nbsp;are&nbsp;identified&nbsp;by&nbsp;braces&nbsp;('{'&nbsp;and&nbsp;'}').</tt></dd></dl>

<dl><dt><a name="Seqname-format_map"><strong>format_map</strong></a>(...)</dt><dd><tt>S.<a href="#Seqname-format_map">format_map</a>(mapping)&nbsp;-&gt;&nbsp;<a href="builtins.html#str">str</a><br>
&nbsp;<br>
Return&nbsp;a&nbsp;formatted&nbsp;version&nbsp;of&nbsp;S,&nbsp;using&nbsp;substitutions&nbsp;from&nbsp;mapping.<br>
The&nbsp;substitutions&nbsp;are&nbsp;identified&nbsp;by&nbsp;braces&nbsp;('{'&nbsp;and&nbsp;'}').</tt></dd></dl>

<dl><dt><a name="Seqname-index"><strong>index</strong></a>(...)</dt><dd><tt>S.<a href="#Seqname-index">index</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;lowest&nbsp;index&nbsp;in&nbsp;S&nbsp;where&nbsp;substring&nbsp;sub&nbsp;is&nbsp;found,<br>
such&nbsp;that&nbsp;sub&nbsp;is&nbsp;contained&nbsp;within&nbsp;S[start:end].&nbsp;&nbsp;Optional<br>
arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are&nbsp;interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.<br>
&nbsp;<br>
Raises&nbsp;ValueError&nbsp;when&nbsp;the&nbsp;substring&nbsp;is&nbsp;not&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Seqname-isalnum"><strong>isalnum</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;an&nbsp;alpha-numeric&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;alpha-numeric&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;alpha-numeric&nbsp;and<br>
there&nbsp;is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Seqname-isalpha"><strong>isalpha</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;an&nbsp;alphabetic&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;alphabetic&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;alphabetic&nbsp;and&nbsp;there<br>
is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Seqname-isascii"><strong>isascii</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;ASCII,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
ASCII&nbsp;characters&nbsp;have&nbsp;code&nbsp;points&nbsp;in&nbsp;the&nbsp;range&nbsp;U+0000-U+007F.<br>
Empty&nbsp;string&nbsp;is&nbsp;ASCII&nbsp;too.</tt></dd></dl>

<dl><dt><a name="Seqname-isdecimal"><strong>isdecimal</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;decimal&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;a&nbsp;decimal&nbsp;string&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;decimal&nbsp;and<br>
there&nbsp;is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Seqname-isdigit"><strong>isdigit</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;digit&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;a&nbsp;digit&nbsp;string&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;digits&nbsp;and&nbsp;there<br>
is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Seqname-isidentifier"><strong>isidentifier</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;valid&nbsp;Python&nbsp;identifier,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
Call&nbsp;keyword.iskeyword(s)&nbsp;to&nbsp;test&nbsp;whether&nbsp;string&nbsp;s&nbsp;is&nbsp;a&nbsp;reserved&nbsp;identifier,<br>
such&nbsp;as&nbsp;"def"&nbsp;or&nbsp;"class".</tt></dd></dl>

<dl><dt><a name="Seqname-islower"><strong>islower</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;lowercase&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;lowercase&nbsp;if&nbsp;all&nbsp;cased&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;lowercase&nbsp;and<br>
there&nbsp;is&nbsp;at&nbsp;least&nbsp;one&nbsp;cased&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Seqname-isnumeric"><strong>isnumeric</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;numeric&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;numeric&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;numeric&nbsp;and&nbsp;there&nbsp;is&nbsp;at<br>
least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Seqname-isprintable"><strong>isprintable</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;printable,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;printable&nbsp;if&nbsp;all&nbsp;of&nbsp;its&nbsp;characters&nbsp;are&nbsp;considered&nbsp;printable&nbsp;in<br>
repr()&nbsp;or&nbsp;if&nbsp;it&nbsp;is&nbsp;empty.</tt></dd></dl>

<dl><dt><a name="Seqname-isspace"><strong>isspace</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;whitespace&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;whitespace&nbsp;if&nbsp;all&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;whitespace&nbsp;and&nbsp;there<br>
is&nbsp;at&nbsp;least&nbsp;one&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Seqname-istitle"><strong>istitle</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;a&nbsp;title-cased&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
In&nbsp;a&nbsp;title-cased&nbsp;string,&nbsp;upper-&nbsp;and&nbsp;title-case&nbsp;characters&nbsp;may&nbsp;only<br>
follow&nbsp;uncased&nbsp;characters&nbsp;and&nbsp;lowercase&nbsp;characters&nbsp;only&nbsp;cased&nbsp;ones.</tt></dd></dl>

<dl><dt><a name="Seqname-isupper"><strong>isupper</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;string&nbsp;is&nbsp;an&nbsp;uppercase&nbsp;string,&nbsp;False&nbsp;otherwise.<br>
&nbsp;<br>
A&nbsp;string&nbsp;is&nbsp;uppercase&nbsp;if&nbsp;all&nbsp;cased&nbsp;characters&nbsp;in&nbsp;the&nbsp;string&nbsp;are&nbsp;uppercase&nbsp;and<br>
there&nbsp;is&nbsp;at&nbsp;least&nbsp;one&nbsp;cased&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Seqname-join"><strong>join</strong></a>(self, iterable, /)</dt><dd><tt>Concatenate&nbsp;any&nbsp;number&nbsp;of&nbsp;strings.<br>
&nbsp;<br>
The&nbsp;string&nbsp;whose&nbsp;method&nbsp;is&nbsp;called&nbsp;is&nbsp;inserted&nbsp;in&nbsp;between&nbsp;each&nbsp;given&nbsp;string.<br>
The&nbsp;result&nbsp;is&nbsp;returned&nbsp;as&nbsp;a&nbsp;new&nbsp;string.<br>
&nbsp;<br>
Example:&nbsp;'.'.<a href="#Seqname-join">join</a>(['ab',&nbsp;'pq',&nbsp;'rs'])&nbsp;-&gt;&nbsp;'ab.pq.rs'</tt></dd></dl>

<dl><dt><a name="Seqname-ljust"><strong>ljust</strong></a>(self, width, fillchar=' ', /)</dt><dd><tt>Return&nbsp;a&nbsp;left-justified&nbsp;string&nbsp;of&nbsp;length&nbsp;width.<br>
&nbsp;<br>
Padding&nbsp;is&nbsp;done&nbsp;using&nbsp;the&nbsp;specified&nbsp;fill&nbsp;character&nbsp;(default&nbsp;is&nbsp;a&nbsp;space).</tt></dd></dl>

<dl><dt><a name="Seqname-lower"><strong>lower</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;converted&nbsp;to&nbsp;lowercase.</tt></dd></dl>

<dl><dt><a name="Seqname-lstrip"><strong>lstrip</strong></a>(self, chars=None, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;with&nbsp;leading&nbsp;whitespace&nbsp;removed.<br>
&nbsp;<br>
If&nbsp;chars&nbsp;is&nbsp;given&nbsp;and&nbsp;not&nbsp;None,&nbsp;remove&nbsp;characters&nbsp;in&nbsp;chars&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="Seqname-partition"><strong>partition</strong></a>(self, sep, /)</dt><dd><tt>Partition&nbsp;the&nbsp;string&nbsp;into&nbsp;three&nbsp;parts&nbsp;using&nbsp;the&nbsp;given&nbsp;separator.<br>
&nbsp;<br>
This&nbsp;will&nbsp;search&nbsp;for&nbsp;the&nbsp;separator&nbsp;in&nbsp;the&nbsp;string.&nbsp;&nbsp;If&nbsp;the&nbsp;separator&nbsp;is&nbsp;found,<br>
returns&nbsp;a&nbsp;3-tuple&nbsp;containing&nbsp;the&nbsp;part&nbsp;before&nbsp;the&nbsp;separator,&nbsp;the&nbsp;separator<br>
itself,&nbsp;and&nbsp;the&nbsp;part&nbsp;after&nbsp;it.<br>
&nbsp;<br>
If&nbsp;the&nbsp;separator&nbsp;is&nbsp;not&nbsp;found,&nbsp;returns&nbsp;a&nbsp;3-tuple&nbsp;containing&nbsp;the&nbsp;original&nbsp;string<br>
and&nbsp;two&nbsp;empty&nbsp;strings.</tt></dd></dl>

<dl><dt><a name="Seqname-replace"><strong>replace</strong></a>(self, old, new, count=-1, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;with&nbsp;all&nbsp;occurrences&nbsp;of&nbsp;substring&nbsp;old&nbsp;replaced&nbsp;by&nbsp;new.<br>
&nbsp;<br>
&nbsp;&nbsp;count<br>
&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;occurrences&nbsp;to&nbsp;replace.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;(the&nbsp;default&nbsp;value)&nbsp;means&nbsp;replace&nbsp;all&nbsp;occurrences.<br>
&nbsp;<br>
If&nbsp;the&nbsp;optional&nbsp;argument&nbsp;count&nbsp;is&nbsp;given,&nbsp;only&nbsp;the&nbsp;first&nbsp;count&nbsp;occurrences&nbsp;are<br>
replaced.</tt></dd></dl>

<dl><dt><a name="Seqname-rfind"><strong>rfind</strong></a>(...)</dt><dd><tt>S.<a href="#Seqname-rfind">rfind</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;highest&nbsp;index&nbsp;in&nbsp;S&nbsp;where&nbsp;substring&nbsp;sub&nbsp;is&nbsp;found,<br>
such&nbsp;that&nbsp;sub&nbsp;is&nbsp;contained&nbsp;within&nbsp;S[start:end].&nbsp;&nbsp;Optional<br>
arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are&nbsp;interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.<br>
&nbsp;<br>
Return&nbsp;-1&nbsp;on&nbsp;failure.</tt></dd></dl>

<dl><dt><a name="Seqname-rindex"><strong>rindex</strong></a>(...)</dt><dd><tt>S.<a href="#Seqname-rindex">rindex</a>(sub[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;int<br>
&nbsp;<br>
Return&nbsp;the&nbsp;highest&nbsp;index&nbsp;in&nbsp;S&nbsp;where&nbsp;substring&nbsp;sub&nbsp;is&nbsp;found,<br>
such&nbsp;that&nbsp;sub&nbsp;is&nbsp;contained&nbsp;within&nbsp;S[start:end].&nbsp;&nbsp;Optional<br>
arguments&nbsp;start&nbsp;and&nbsp;end&nbsp;are&nbsp;interpreted&nbsp;as&nbsp;in&nbsp;slice&nbsp;notation.<br>
&nbsp;<br>
Raises&nbsp;ValueError&nbsp;when&nbsp;the&nbsp;substring&nbsp;is&nbsp;not&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Seqname-rjust"><strong>rjust</strong></a>(self, width, fillchar=' ', /)</dt><dd><tt>Return&nbsp;a&nbsp;right-justified&nbsp;string&nbsp;of&nbsp;length&nbsp;width.<br>
&nbsp;<br>
Padding&nbsp;is&nbsp;done&nbsp;using&nbsp;the&nbsp;specified&nbsp;fill&nbsp;character&nbsp;(default&nbsp;is&nbsp;a&nbsp;space).</tt></dd></dl>

<dl><dt><a name="Seqname-rpartition"><strong>rpartition</strong></a>(self, sep, /)</dt><dd><tt>Partition&nbsp;the&nbsp;string&nbsp;into&nbsp;three&nbsp;parts&nbsp;using&nbsp;the&nbsp;given&nbsp;separator.<br>
&nbsp;<br>
This&nbsp;will&nbsp;search&nbsp;for&nbsp;the&nbsp;separator&nbsp;in&nbsp;the&nbsp;string,&nbsp;starting&nbsp;at&nbsp;the&nbsp;end.&nbsp;If<br>
the&nbsp;separator&nbsp;is&nbsp;found,&nbsp;returns&nbsp;a&nbsp;3-tuple&nbsp;containing&nbsp;the&nbsp;part&nbsp;before&nbsp;the<br>
separator,&nbsp;the&nbsp;separator&nbsp;itself,&nbsp;and&nbsp;the&nbsp;part&nbsp;after&nbsp;it.<br>
&nbsp;<br>
If&nbsp;the&nbsp;separator&nbsp;is&nbsp;not&nbsp;found,&nbsp;returns&nbsp;a&nbsp;3-tuple&nbsp;containing&nbsp;two&nbsp;empty&nbsp;strings<br>
and&nbsp;the&nbsp;original&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Seqname-rsplit"><strong>rsplit</strong></a>(self, /, sep=None, maxsplit=-1)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;words&nbsp;in&nbsp;the&nbsp;string,&nbsp;using&nbsp;sep&nbsp;as&nbsp;the&nbsp;delimiter&nbsp;string.<br>
&nbsp;<br>
&nbsp;&nbsp;sep<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;delimiter&nbsp;according&nbsp;which&nbsp;to&nbsp;split&nbsp;the&nbsp;string.<br>
&nbsp;&nbsp;&nbsp;&nbsp;None&nbsp;(the&nbsp;default&nbsp;value)&nbsp;means&nbsp;split&nbsp;according&nbsp;to&nbsp;any&nbsp;whitespace,<br>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;discard&nbsp;empty&nbsp;strings&nbsp;from&nbsp;the&nbsp;result.<br>
&nbsp;&nbsp;maxsplit<br>
&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;splits&nbsp;to&nbsp;do.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;(the&nbsp;default&nbsp;value)&nbsp;means&nbsp;no&nbsp;limit.<br>
&nbsp;<br>
Splits&nbsp;are&nbsp;done&nbsp;starting&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;string&nbsp;and&nbsp;working&nbsp;to&nbsp;the&nbsp;front.</tt></dd></dl>

<dl><dt><a name="Seqname-rstrip"><strong>rstrip</strong></a>(self, chars=None, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;with&nbsp;trailing&nbsp;whitespace&nbsp;removed.<br>
&nbsp;<br>
If&nbsp;chars&nbsp;is&nbsp;given&nbsp;and&nbsp;not&nbsp;None,&nbsp;remove&nbsp;characters&nbsp;in&nbsp;chars&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="Seqname-split"><strong>split</strong></a>(self, /, sep=None, maxsplit=-1)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;words&nbsp;in&nbsp;the&nbsp;string,&nbsp;using&nbsp;sep&nbsp;as&nbsp;the&nbsp;delimiter&nbsp;string.<br>
&nbsp;<br>
sep<br>
&nbsp;&nbsp;The&nbsp;delimiter&nbsp;according&nbsp;which&nbsp;to&nbsp;split&nbsp;the&nbsp;string.<br>
&nbsp;&nbsp;None&nbsp;(the&nbsp;default&nbsp;value)&nbsp;means&nbsp;split&nbsp;according&nbsp;to&nbsp;any&nbsp;whitespace,<br>
&nbsp;&nbsp;and&nbsp;discard&nbsp;empty&nbsp;strings&nbsp;from&nbsp;the&nbsp;result.<br>
maxsplit<br>
&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;splits&nbsp;to&nbsp;do.<br>
&nbsp;&nbsp;-1&nbsp;(the&nbsp;default&nbsp;value)&nbsp;means&nbsp;no&nbsp;limit.</tt></dd></dl>

<dl><dt><a name="Seqname-splitlines"><strong>splitlines</strong></a>(self, /, keepends=False)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;lines&nbsp;in&nbsp;the&nbsp;string,&nbsp;breaking&nbsp;at&nbsp;line&nbsp;boundaries.<br>
&nbsp;<br>
Line&nbsp;breaks&nbsp;are&nbsp;not&nbsp;included&nbsp;in&nbsp;the&nbsp;resulting&nbsp;list&nbsp;unless&nbsp;keepends&nbsp;is&nbsp;given&nbsp;and<br>
true.</tt></dd></dl>

<dl><dt><a name="Seqname-startswith"><strong>startswith</strong></a>(...)</dt><dd><tt>S.<a href="#Seqname-startswith">startswith</a>(prefix[,&nbsp;start[,&nbsp;end]])&nbsp;-&gt;&nbsp;bool<br>
&nbsp;<br>
Return&nbsp;True&nbsp;if&nbsp;S&nbsp;starts&nbsp;with&nbsp;the&nbsp;specified&nbsp;prefix,&nbsp;False&nbsp;otherwise.<br>
With&nbsp;optional&nbsp;start,&nbsp;test&nbsp;S&nbsp;beginning&nbsp;at&nbsp;that&nbsp;position.<br>
With&nbsp;optional&nbsp;end,&nbsp;stop&nbsp;comparing&nbsp;S&nbsp;at&nbsp;that&nbsp;position.<br>
prefix&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;tuple&nbsp;of&nbsp;strings&nbsp;to&nbsp;try.</tt></dd></dl>

<dl><dt><a name="Seqname-strip"><strong>strip</strong></a>(self, chars=None, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;with&nbsp;leading&nbsp;and&nbsp;trailing&nbsp;whitespace&nbsp;removed.<br>
&nbsp;<br>
If&nbsp;chars&nbsp;is&nbsp;given&nbsp;and&nbsp;not&nbsp;None,&nbsp;remove&nbsp;characters&nbsp;in&nbsp;chars&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="Seqname-swapcase"><strong>swapcase</strong></a>(self, /)</dt><dd><tt>Convert&nbsp;uppercase&nbsp;characters&nbsp;to&nbsp;lowercase&nbsp;and&nbsp;lowercase&nbsp;characters&nbsp;to&nbsp;uppercase.</tt></dd></dl>

<dl><dt><a name="Seqname-title"><strong>title</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;version&nbsp;of&nbsp;the&nbsp;string&nbsp;where&nbsp;each&nbsp;word&nbsp;is&nbsp;titlecased.<br>
&nbsp;<br>
More&nbsp;specifically,&nbsp;words&nbsp;start&nbsp;with&nbsp;uppercased&nbsp;characters&nbsp;and&nbsp;all&nbsp;remaining<br>
cased&nbsp;characters&nbsp;have&nbsp;lower&nbsp;case.</tt></dd></dl>

<dl><dt><a name="Seqname-translate"><strong>translate</strong></a>(self, table, /)</dt><dd><tt>Replace&nbsp;each&nbsp;character&nbsp;in&nbsp;the&nbsp;string&nbsp;using&nbsp;the&nbsp;given&nbsp;translation&nbsp;table.<br>
&nbsp;<br>
&nbsp;&nbsp;table<br>
&nbsp;&nbsp;&nbsp;&nbsp;Translation&nbsp;table,&nbsp;which&nbsp;must&nbsp;be&nbsp;a&nbsp;mapping&nbsp;of&nbsp;Unicode&nbsp;ordinals&nbsp;to<br>
&nbsp;&nbsp;&nbsp;&nbsp;Unicode&nbsp;ordinals,&nbsp;strings,&nbsp;or&nbsp;None.<br>
&nbsp;<br>
The&nbsp;table&nbsp;must&nbsp;implement&nbsp;lookup/indexing&nbsp;via&nbsp;__getitem__,&nbsp;for&nbsp;instance&nbsp;a<br>
dictionary&nbsp;or&nbsp;list.&nbsp;&nbsp;If&nbsp;this&nbsp;operation&nbsp;raises&nbsp;LookupError,&nbsp;the&nbsp;character&nbsp;is<br>
left&nbsp;untouched.&nbsp;&nbsp;Characters&nbsp;mapped&nbsp;to&nbsp;None&nbsp;are&nbsp;deleted.</tt></dd></dl>

<dl><dt><a name="Seqname-upper"><strong>upper</strong></a>(self, /)</dt><dd><tt>Return&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;string&nbsp;converted&nbsp;to&nbsp;uppercase.</tt></dd></dl>

<dl><dt><a name="Seqname-zfill"><strong>zfill</strong></a>(self, width, /)</dt><dd><tt>Pad&nbsp;a&nbsp;numeric&nbsp;string&nbsp;with&nbsp;zeros&nbsp;on&nbsp;the&nbsp;left,&nbsp;to&nbsp;fill&nbsp;a&nbsp;field&nbsp;of&nbsp;the&nbsp;given&nbsp;width.<br>
&nbsp;<br>
The&nbsp;string&nbsp;is&nbsp;never&nbsp;truncated.</tt></dd></dl>

<hr>
Static methods inherited from <a href="builtins.html#str">builtins.str</a>:<br>
<dl><dt><a name="Seqname-maketrans"><strong>maketrans</strong></a>(...)</dt><dd><tt>Return&nbsp;a&nbsp;translation&nbsp;table&nbsp;usable&nbsp;for&nbsp;<a href="builtins.html#str">str</a>.<a href="#Seqname-translate">translate</a>().<br>
&nbsp;<br>
If&nbsp;there&nbsp;is&nbsp;only&nbsp;one&nbsp;argument,&nbsp;it&nbsp;must&nbsp;be&nbsp;a&nbsp;dictionary&nbsp;mapping&nbsp;Unicode<br>
ordinals&nbsp;(integers)&nbsp;or&nbsp;characters&nbsp;to&nbsp;Unicode&nbsp;ordinals,&nbsp;strings&nbsp;or&nbsp;None.<br>
Character&nbsp;keys&nbsp;will&nbsp;be&nbsp;then&nbsp;converted&nbsp;to&nbsp;ordinals.<br>
If&nbsp;there&nbsp;are&nbsp;two&nbsp;arguments,&nbsp;they&nbsp;must&nbsp;be&nbsp;strings&nbsp;of&nbsp;equal&nbsp;length,&nbsp;and<br>
in&nbsp;the&nbsp;resulting&nbsp;dictionary,&nbsp;each&nbsp;character&nbsp;in&nbsp;x&nbsp;will&nbsp;be&nbsp;mapped&nbsp;to&nbsp;the<br>
character&nbsp;at&nbsp;the&nbsp;same&nbsp;position&nbsp;in&nbsp;y.&nbsp;If&nbsp;there&nbsp;is&nbsp;a&nbsp;third&nbsp;argument,&nbsp;it<br>
must&nbsp;be&nbsp;a&nbsp;string,&nbsp;whose&nbsp;characters&nbsp;will&nbsp;be&nbsp;mapped&nbsp;to&nbsp;None&nbsp;in&nbsp;the&nbsp;result.</tt></dd></dl>

</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-create_regex"><strong>create_regex</strong></a>(string: Union[str, pathlib.Path], width: str = 'any') -&gt; str</dt><dd><tt>Create&nbsp;regex&nbsp;pattern&nbsp;to&nbsp;match&nbsp;paths/strings&nbsp;resembling&nbsp;the&nbsp;format&nbsp;of&nbsp;the&nbsp;input&nbsp;string.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;string&nbsp;or&nbsp;path&nbsp;to&nbsp;use&nbsp;as&nbsp;a&nbsp;basis&nbsp;for&nbsp;the&nbsp;pattern.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;Defines&nbsp;how&nbsp;frame&nbsp;number&nbsp;width&nbsp;will&nbsp;be&nbsp;matched.&nbsp;Options:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;any&nbsp;(default):&nbsp;Frame&nbsp;numbers&nbsp;of&nbsp;any&nbsp;width&nbsp;will&nbsp;match.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;min:&nbsp;Frame&nbsp;numbers&nbsp;with&nbsp;the&nbsp;same&nbsp;width&nbsp;or&nbsp;wider&nbsp;will&nbsp;match.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;max:&nbsp;Frame&nbsp;numbers&nbsp;with&nbsp;the&nbsp;same&nbsp;width&nbsp;or&nbsp;narrower&nbsp;will&nbsp;match<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;exact:&nbsp;Only&nbsp;frame&nbsp;numbers&nbsp;with&nbsp;the&nbsp;same&nbsp;width&nbsp;will&nbsp;match.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;resulting&nbsp;regex&nbsp;pattern.&nbsp;If&nbsp;no&nbsp;framecode&nbsp;is&nbsp;found,&nbsp;will&nbsp;return&nbsp;a&nbsp;regex&nbsp;pattern<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;matches&nbsp;the&nbsp;original&nbsp;string&nbsp;exactly.</tt></dd></dl>
 <dl><dt><a name="-format_numbers"><strong>format_numbers</strong></a>(numbers: Sequence[int]) -&gt; str</dt><dd><tt>Generates&nbsp;a&nbsp;string&nbsp;representation&nbsp;of&nbsp;an&nbsp;iterable&nbsp;containing&nbsp;integers.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;numbers:&nbsp;Iterable&nbsp;containing&nbsp;integers<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;(<a href="builtins.html#str">str</a>):&nbsp;String&nbsp;representation&nbsp;of&nbsp;input&nbsp;numbers&nbsp;(example:&nbsp;"1-5,&nbsp;10-16x2,&nbsp;20,&nbsp;21")</tt></dd></dl>
 <dl><dt><a name="-generate_framecode"><strong>generate_framecode</strong></a>(framecode_type: str, width: int) -&gt; str</dt><dd><tt>Generate&nbsp;a&nbsp;format&nbsp;code&nbsp;or&nbsp;frame&nbsp;number&nbsp;placeholder.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;framecode_type:&nbsp;The&nbsp;framecode&nbsp;type&nbsp;to&nbsp;output.&nbsp;Currently&nbsp;supported:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'format_code',&nbsp;'modulo',&nbsp;'numbersign'<br>
&nbsp;&nbsp;&nbsp;&nbsp;width:&nbsp;The&nbsp;(minimum)&nbsp;fill&nbsp;width&nbsp;of&nbsp;the&nbsp;output&nbsp;code.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;output&nbsp;code.</tt></dd></dl>
 <dl><dt><a name="-get_frame_number"><strong>get_frame_number</strong></a>(string: Union[str, pathlib.Path]) -&gt; int</dt><dd><tt>Extract&nbsp;frame&nbsp;number&nbsp;from&nbsp;the&nbsp;given&nbsp;string&nbsp;or&nbsp;Path.&nbsp;The&nbsp;frame&nbsp;number&nbsp;is&nbsp;defined&nbsp;as<br>
the&nbsp;last&nbsp;consecutive&nbsp;set&nbsp;of&nbsp;digits&nbsp;in&nbsp;the&nbsp;string.&nbsp;Note&nbsp;that&nbsp;if&nbsp;the&nbsp;input&nbsp;is&nbsp;or&nbsp;resembles<br>
a&nbsp;path,&nbsp;only&nbsp;the&nbsp;basename&nbsp;will&nbsp;be&nbsp;checked&nbsp;for&nbsp;a&nbsp;frame&nbsp;number.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;string&nbsp;or&nbsp;Path&nbsp;to&nbsp;extract&nbsp;the&nbsp;frame&nbsp;number&nbsp;form.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;frame&nbsp;number&nbsp;found&nbsp;in&nbsp;this&nbsp;string&nbsp;as&nbsp;an&nbsp;integer.</tt></dd></dl>
 <dl><dt><a name="-get_framecode"><strong>get_framecode</strong></a>(string: Union[str, pathlib.Path]) -&gt; str</dt><dd><tt>Extract&nbsp;framecode&nbsp;(part&nbsp;that&nbsp;represents&nbsp;a&nbsp;frame&nbsp;number)&nbsp;from&nbsp;a&nbsp;string&nbsp;or&nbsp;Path.<br>
Note&nbsp;that&nbsp;if&nbsp;the&nbsp;input&nbsp;is&nbsp;or&nbsp;resembles&nbsp;a&nbsp;path,&nbsp;only&nbsp;the&nbsp;basename&nbsp;<br>
will&nbsp;be&nbsp;checked&nbsp;for&nbsp;a&nbsp;frame&nbsp;number.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;string&nbsp;or&nbsp;Path&nbsp;to&nbsp;parse.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;framecode&nbsp;portion&nbsp;of&nbsp;the&nbsp;string.</tt></dd></dl>
 <dl><dt><a name="-get_framecode_type"><strong>get_framecode_type</strong></a>(string: str) -&gt; Union[str, NoneType]</dt><dd><tt>Determine&nbsp;the&nbsp;framecode&nbsp;type&nbsp;of&nbsp;this&nbsp;string&nbsp;or&nbsp;Path.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;string&nbsp;or&nbsp;Path&nbsp;to&nbsp;analyze.<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;determined&nbsp;framecode&nbsp;type.&nbsp;None&nbsp;if&nbsp;no&nbsp;framecode&nbsp;is&nbsp;found.</tt></dd></dl>
 <dl><dt><a name="-get_framecode_width"><strong>get_framecode_width</strong></a>(string: str) -&gt; Union[str, NoneType]</dt><dd><tt>Determine&nbsp;the&nbsp;fill&nbsp;width&nbsp;of&nbsp;the&nbsp;framecode&nbsp;in&nbsp;string&nbsp;or&nbsp;Path.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;string&nbsp;or&nbsp;Path&nbsp;to&nbsp;analyze.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;fill&nbsp;width.&nbsp;None&nbsp;if&nbsp;not&nbsp;framecode&nbsp;is&nbsp;found.</tt></dd></dl>
 <dl><dt><a name="-has_framecode"><strong>has_framecode</strong></a>(string: Union[str, pathlib.Path]) -&gt; bool</dt><dd><tt>Determine&nbsp;whether&nbsp;the&nbsp;given&nbsp;string&nbsp;or&nbsp;path&nbsp;contains&nbsp;a&nbsp;framecode.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;string&nbsp;or&nbsp;Path&nbsp;to&nbsp;analyze.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;True&nbsp;if&nbsp;a&nbsp;framecode&nbsp;is&nbsp;found,&nbsp;False&nbsp;if&nbsp;not.</tt></dd></dl>
 <dl><dt><a name="-parse_numbers"><strong>parse_numbers</strong></a>(string: str) -&gt; Generator[int, NoneType, NoneType]</dt><dd><tt>Generate&nbsp;a&nbsp;set&nbsp;of&nbsp;integers&nbsp;from&nbsp;a&nbsp;string&nbsp;representation.<br>
&nbsp;<br>
The&nbsp;following&nbsp;syntax,&nbsp;and&nbsp;any&nbsp;combination&nbsp;thereof,&nbsp;is&nbsp;supported:<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;A-B:&nbsp;All&nbsp;integers&nbsp;from&nbsp;A&nbsp;to&nbsp;B&nbsp;(both&nbsp;inclusive)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;A-B-C:&nbsp;All&nbsp;integers&nbsp;from&nbsp;A&nbsp;to&nbsp;B&nbsp;(both&nbsp;inclusive)&nbsp;in&nbsp;increments&nbsp;of&nbsp;C<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;A,&nbsp;B,&nbsp;C:&nbsp;Integers&nbsp;A,&nbsp;B&nbsp;and&nbsp;C<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;A&nbsp;B&nbsp;C:&nbsp;Integers&nbsp;A,&nbsp;B&nbsp;and&nbsp;C<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;A:&nbsp;Integer&nbsp;A,&nbsp;where&nbsp;A&nbsp;is&nbsp;a&nbsp;negative&nbsp;number<br>
Units&nbsp;can&nbsp;be&nbsp;separated&nbsp;by&nbsp;either&nbsp;spaces&nbsp;or&nbsp;commas.&nbsp;Any&nbsp;syntax&nbsp;not&nbsp;understood&nbsp;will&nbsp;be&nbsp;skipped&nbsp;over.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;string&nbsp;to&nbsp;parse.<br>
&nbsp;<br>
Yields:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;next&nbsp;integer&nbsp;found&nbsp;in&nbsp;the&nbsp;string&nbsp;representation.</tt></dd></dl>
 <dl><dt><a name="-replace_framecode"><strong>replace_framecode</strong></a>(string: str, repl: str) -&gt; str</dt><dd><tt>Replace&nbsp;framecode&nbsp;in&nbsp;this&nbsp;string&nbsp;or&nbsp;Path.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;string&nbsp;to&nbsp;search.<br>
&nbsp;&nbsp;&nbsp;&nbsp;repl:&nbsp;The&nbsp;string&nbsp;to&nbsp;sub&nbsp;in.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;The&nbsp;input&nbsp;string&nbsp;with&nbsp;its&nbsp;framecode&nbsp;replaced.&nbsp;If&nbsp;no&nbsp;framecode&nbsp;is&nbsp;found,&nbsp;returns&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;original&nbsp;string.</tt></dd></dl>
 <dl><dt><a name="-translate_framecode"><strong>translate_framecode</strong></a>(string: Union[str, pathlib.Path], to_type: str) -&gt; str</dt><dd><tt>Translate&nbsp;framecode&nbsp;to&nbsp;specified&nbsp;type.&nbsp;If&nbsp;no&nbsp;framecode&nbsp;is&nbsp;found,&nbsp;return&nbsp;the&nbsp;original&nbsp;string.<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;&nbsp;string:&nbsp;the&nbsp;string&nbsp;or&nbsp;Path&nbsp;to&nbsp;translate.<br>
&nbsp;&nbsp;&nbsp;&nbsp;to_type:&nbsp;the&nbsp;framecode&nbsp;type&nbsp;to&nbsp;translate&nbsp;to.<br>
&nbsp;<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;input&nbsp;string&nbsp;with&nbsp;its&nbsp;framecode&nbsp;translated.&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Returns&nbsp;the&nbsp;original&nbsp;string&nbsp;if&nbsp;no&nbsp;framecode&nbsp;was&nbsp;found.<br>
&nbsp;<br>
Raises:<br>
&nbsp;&nbsp;&nbsp;&nbsp;ValueError:&nbsp;if&nbsp;"to_type"&nbsp;is&nbsp;set&nbsp;to&nbsp;a&nbsp;framecode&nbsp;type&nbsp;that&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;does&nbsp;not&nbsp;exist&nbsp;or&nbsp;does&nbsp;not&nbsp;allow&nbsp;framecode&nbsp;creation.</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>__all__</strong> = ['generate_framecode', 'get_framecode', 'get_frame_number', 'has_framecode', 'get_framecode_type', 'get_framecode_width', 'replace_framecode', 'replace_framecode', 'translate_framecode', 'create_regex', 'parse_numbers', 'format_numbers', 'Seqname']</td></tr></table>
</body></html>